Category: CoreJava

Q) what is oops?
A) 1.jvm loads .class byte into memory(static blocks are executed)

2.after loads it calls to main method to start execution.

class contains 5 variables

1.variables =>local,instance,static variable

2.methods--instance{},static{}

3.constructor--default,user defined constructor

4.instance blocks

5.static blocks(executed during .class loading)

note:instance blocks are executed first compare to constructor blocks is executed

Object class in Java

ref:https://www.javatpoint.com/object-class.

object is instance of a class

The Object class is the parent class of all the classes in java by default

object class methods(11)::

boolean equals(object o)

class getclass()
int hashcode;

void notify();

void notifyall();

String toString();

public final void wait();//wait lo ne inka 2 methods vunnayi but parameters are

public final void wait(long timeout,int nanos)throws InterruptedException

protected object clone()throws cloneNotSupportedException

protected void finalize()throws throwable;
~~~~~~~~~~~~~~~~~
Q) How many Ways to Create an Object in Java

A) 5 ways

1.Using new Operator.:

Ex: MyClass obj = new MyClass();

2.Using newInstance() method (Reflection).

MyClass obj = (MyClass) Class.forName("MyClass").getDeclaredConstructor().newInstance();

3.Using Constructor newInstance() method.

Constructor<MyClass> constructor = MyClass.class.getConstructor();
MyClass obj = constructor.newInstance();


4.Using clone() method.

MyClass obj1 = new MyClass();
MyClass obj2 = (MyClass) obj1.clone();

5.Using Deserialization

ObjectInputStream in = new ObjectInputStream(new FileInputStream("data.obj"));
MyClass obj = (MyClass) in.readObject();
in.close();


6.Using Factory Methods.

MyClass obj = MyClass.createInstance();

for ex: List.of(1, 2, 3)

~~~~~~~~~~~~~~~~~~~~~~~~~~~
Q) upendra sir told:about hashcode and equals method in hashset.

A) samehash code vunte apude mathrame equals ki cal avuthundi.

so its override the object with new object.

samehashcode aunte meaning is 2 objects having same data.

pubic int hashcode(){

return name.hashcode()+age.hashcode.sirname.hashcode();//if hshcode

is same then it cals to equals method.

}

hashset lo duplicate data ni set chesi print chesthe ..duplicate

data kuda print avuthundi.ila duplicate print avakunda vundalante

we need to override hashcode and equals by our own methods.

ila override cheyakapothe inbuilt ga vunna object class methods cal

avuthundi ok na.object class equals method lo dummy logic vundi

equals comparison logic ledu.

~~~~~~~~~~~~~~~~~~~~

Q) Locking in java ?
A) Class level lock is achieved by keyword Sychronized(DemoClass.class)

where as object level is achieved only by synchronized(this)

keyword.

Class level locking ::

it prevents multiple threads to enter in synchronized block

in any of all available instances on runtime. This means if in

runtime there are 100

instances of DemoClass, then only one thread will be able to

execute demoMethod()

in any one of instance at a time, and all other instances will be

locked for other threads.

This should always be done to make static data thread safe.

public class DemoClass

{

public void demoMethod(){

synchronized (DemoClass.class)

{

//other thread safe code

}

}

}


object level locking::

public class DemoClass

{

public void demoMethod(){

synchronized (this)

{

//other thread safe code

}

}

}
Block-level lock: Lock specific code sections, allowing finer control.
java
Copy code
public void methodName() {
    synchronized (this) {
        // critical section
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Q) what is Hashcode?
A) by nageswararao

Hashcode:

it is unique identification number allotted to the objects by jvm

it is also reference number location of objects,except for string

objects.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Q) Cloning: 

Shallow: if we changed cloneddata ..original data also modified.

A) package com.cloning;

public class ShallowCopyExample implements Cloneable{
    int i;
    int [] arr;
    public ShallowCopyExample(int i, int[] arr) {
        this.i=i;
        this.arr=arr;
    }

    public static void main(String[] args) {
        int arr[] = {3,2,1};
        ShallowCopyExample original = new ShallowCopyExample(2,arr);//2,[3,2,1]
        ShallowCopyExample clonedObject = original.clone();
        clonedObject.arr[0]=12;//[12,2,1]

        System.out.println("Original array first element: " + original.arr[0]); // Outputs 12
//output:
//Original array first element: 12
    }


    @Override
    public ShallowCopyExample clone() {
        try {
            return (ShallowCopyExample) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
//output:
//Original array first element: 12

Deep: not modified in original object if we change in cloned object.

public class DeepCopyExample implements Cloneable {
    int x;               // primitive field
    int[] arr;           // reference field (array)

    public DeepCopyExample(int x, int[] arr) {
        this.x = x;
        this.arr = arr;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        DeepCopyExample cloned = (DeepCopyExample) super.clone(); // Perform shallow copy
        
        // Deep copy the array
        cloned.arr = arr.clone(); // Creates a new array that is a copy of the original
        
        return cloned;
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        int[] arr = {1, 2, 3};
        DeepCopyExample original = new DeepCopyExample(10, arr);
        DeepCopyExample deepCopy = (DeepCopyExample) original.clone(); // Perform deep cloning

        // Modify the array in the cloned object
        deepCopy.arr[0] = 99;

        // Check the original array - change is NOT reflected in the original
        System.out.println("Original array first element: " + original.arr[0]); // Outputs 1
        System.out.println("Deep copy array first element: " + deepCopy.arr[0]); // Outputs 99
    }
}

//output:

Original: Person{name='John Doe', age=30, addresses=[123 Main St, New York, 456 Elm St, Los Angeles]}
Deep Clone: Person{name='John Doe', age=30, addresses=[789 Oak St, New York, 456 Elm St, Los Angeles]}

~~~~~~~~~~~~~~

Q)solid principles?
A)single responsibility : a class have one reason to change.

 A class should have only one reason to change. This means that a class should have only one job or responsibility. 
 If a class has more than one responsibility, it becomes coupled, and changes to one responsibility might affect the other.

open/closed : its open for devlopment closed for modification.

Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. 
This means that the behavior of a module can be extended without modifying its source code.

Liskov substitution: super class must be replaced with subtypes.
interface : small subset features need to be add .use of interfaces
dependency : we use one screen data to other as a dependecies.
~~~~~~~~~~~~~~~~~~~~~~~
Q) how to Creating an Immutable Class in Java

A)To create an immutable class in Java, you need to follow these general principles:

Declare the class as final so it can’t be extended.
Make all of the fields private final so that direct access is not allowed.
Don’t provide setter methods for variables.
Make all mutable fields final so that a field’s value can be assigned only once.


import java.util.Date;

public final class Person {
    private final String name;       // Immutable field
    private final int age;           // Immutable field
    private final Date birthDate;    // Mutable field

    // Constructor
    public Person(String name, int age, Date birthDate) {
        this.name = name;
        this.age = age;
        // Create a defensive copy of the mutable Date object
        this.birthDate = new Date(birthDate.getTime());
    }

    // Getters (no setters)
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public Date getBirthDate() {
        // Return a defensive copy of the mutable Date object
        return new Date(birthDate.getTime());
    }

    // Optionally, you can override toString(), equals(), and hashCode()
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + ", birthDate=" + birthDate + '}';
    }
}
	// Test the immutable class
public class Main {
    public static void main(String[] args) {
        Date birthDate = new Date(); // Current date
        Person person = new Person("Alice", 30, birthDate);

        System.out.println(person); // Person{name='Alice', age=30, birthDate=Mon Nov 06 12:00:00 UTC 2023}

        // Attempting to modify the person instance will fail
        // person.age = 31; // Compilation error: age has private access

        // Modifying the birthDate outside will not affect the Person instance
        birthDate.setYear(2000); // This modifies the original Date object
        System.out.println(person.getBirthDate()); // Still shows the original birth date
    }
}
~~~~~~~~~~~~~
Category: Polymorphism
Q) Polymorphism

A) Ratan says below

Polymorphism::

poly means (many) morphism (forms)

method overloading (static binding/compiletime polymorphism)

method overriding(dynamic binding/runtime polymorphism)

3 types of overloading

1.method overloading

2.constructor overloading

3.operator ovreloading

1.method overloading

class contain morethan one method with same name but diff no of arguments

class contain morethan one method with same name but diff datatypes
class contain morethan one method with same name but diff order


for ex:

m1(int a){

}

m1(int a,int b){

}

m1(char ch){

}

main(){

new Test().m1()//compile time checking on which method is called

is called compiletime polymorphism.

}

2.constructor overload/ but we did not do overriding.

its like method overloading.

Test(int a){

}

Test(int a,int b){

}

Test(Char ch){

}

operator overloading::

Syso(10+"ratan");

Syso(10+"ratan"+"anu"+10+20)

overriding:

previous content is gone,new content is loaded.

to achieve overrridng 2 classes is required with inheritance realtionship required.

class Parent{

//overriden method

void marry(){

sop("block girl")

}

class Child extends Parent{

//if child accepts ok .or write your own impl.

//overrding method

void marry(){

//to write our own implementation.

syso("red")

}

}

}

8 rules :

1.overriden and overriding method signature must be same.

2.in overriden and overriding return type must be same at primitive level in method signature.

but in class level its possible to change return type.

class Animal{

A m1(){

}

}

//mainly to change return type is not posiible.but it is possible to covariant returntype only.

//return must be sub class type is possible is called covariant return type.

class Dog extends Animal {

Dog m1(){

}

}

}

3.If an overridden method is final it is not possible to override that method in child class.

final variables reference are not changed

class Test

{ public static void main(String[] args)

{ final int a=10;

a=a+10; //trying to modify a value it will generate error

System.out.println(a);

}

};

class Test

{ final int a; //instance variable

final static int b; //static variable

};


Polymorphism::

method overloding::

There are two ways to overload the method in java

**By changing number of arguments

void sum(int a,int b)

void sum(int a,int b,int c)

**By changing the data type.

void sum(int a,int b){System.out.println(a+b);}

void sum(double a,double b)

Why Method Overloaing is not possible by changing the return type of method

because of ambiguity,

class Calculation3{

int sum(int a,int b){System.out.println(a+b);}

double sum(int a,int b){System.out.println(a+b);}

public static void main(String args[]){

Calculation3 obj=new Calculation3();

int result=obj.sum(20,20); //Compile Time Error

}

}
Method Overriding in Java
If subclass (child class) has the same method as declared in the parent class, it is known as method overriding in Java.

Rules: 
Same Method Name: The overriding method in the subclass must have the same name as the method in the superclass that it is overriding.
Same Parameters: The overriding method must have the same number and types of parameters as the method in the superclass. 
This ensures compatibility and consistency with the method signature defined in the superclass.
IS-A Relationship (Inheritance): Method overriding requires an IS-A relationship between the subclass and the superclass. 
This means that the subclass must inherit from the superclass, either directly or indirectly, to override its methods.

Same Return Type or Covariant Return Type: The return type of the overriding method can be the same as the return type of 
the overridden method in the superclass, or it can be a subtype of the return type in the superclass. This is known as the 
covariant return type, introduced in Java 5.

Access Modifier Restrictions: The access modifier of the overriding method must be the same as or less restrictive than the 
access modifier of the overridden method in the superclass. Specifically, a method declared as public in the superclass 
can be overridden as public or protected but not as private. Similarly, a method declared as protected in the superclass
 can be overridden as protected or public but not as private. A method declared as default (package-private) in the superclass 
 can be overridden with default, protected, or public, but not as private.

No Final Methods: Methods declared as final in the superclass cannot be overridden in the subclass. This is because 
final methods cannot be modified or extended.

No Static Methods: Static methods in Java are resolved at compile time and cannot be overridden. Instead, 
they are hidden in the subclass if a method with the same signature is defined in the subclass.

Yes, by method overloading it is possible.
~~~~~~~~~~~~~~~~
Category: Java 8
Q) what is Java 8 features?

A) --> Lambda expressions,

--> Method references,

--> Functional interfaces,

--> Stream API,

--> Default methods,

--> Base64 Encode Decode,

--> Optional class,

--> Collectors class,

--> ForEach() method,

--> Parallel array sorting,

--> Nashorn JavaScript Engine,

--> Parallel Array Sorting,

--> Type and Repating Annotations,

--> IO Enhancements,

--> Concurrency Enhancements,

--> JDBC Enhancements etc.
~~~~~~~~~~~~~~~~
Q) how to use comparator in java 8

A) list.sort(Comparator.comparing(DentalMasterDTOList::getLastUpdateDttm.reversed()));

//you can create constructor in the abstract class whereas you can't do this in interface.

//checking in ternary operator

///*int val1 = 10;

int val2 = 20;

int max = val1 >= val2 ? val1 : val2;

*/
~~~~~~~~~~~~~~~~
Q) about Lambda expression:

A) step 1:

it is an ananynomous function(name less function and it is not having name,modifier,return type)

for example :

public void test(){

syso("hello");

}

//Lambda expression style is so here no method name and modifier and return type so we write below

but we add some extra symbol like -->

()-->{syso("hello");}

step 2:

body having multiple stmts then we use curly braces.

step 3:

type inference -->means based on situation compiler assign type

ex: public void sum(int a,int b){

syso(a+b);

}

//Lambda expression style

(int a,int b)->syso(a+b);

in above no need to mention type of a,b ,so the compiler identify based on its context and assigned.so

(a,b)->syso(a+b);

step 4 :

it wil return single data like int size = s.length(); here braces is optional.

so we write s->s.length();



Java Lambda Expression Syntax :

(argument-list) -> {body}

Java lambda expression is consisted of three components.

1) Argument-list: It can be empty or non-empty as well.

2) Arrow-token: It is used to link arguments-list and body of expression.

3) Body: It contains expressions and statements for lambda expression.

No Parameter Syntax

() -> {

//Body of no parameter lambda

}

~~~~~~~~~~~~~~~~

Q) functional interface(having single abstract method)

A) step 1:

oka abstract method vundali.enni default method,static methods ayina vunda vachhu.

ex:

inteface A{

public void test();

default void m1(){}

public static void test(){}

}

~~~~~~~~~~~~~~~~


Q) method references ::

A) The double colon (::) operator, also known as method reference operator in Java,

is used to call a method by referring to it with the help of its class directly. They behave exactly as the lambda expressions.

for Ex:

Predicate p = String::isEmpty;
~~~~~~~~~~~~~~~~
Q) functional interfaces :(SAM)


A) from (oracle)
Functional interfaces provide target types for lambda expressions and method references.

Each functional interface has a single abstract method, called the functional method for that functional interface,

to which the lambda expression's parameter and return types are matched or adapted. Functional interfaces can provide a target type in multiple contexts,

such as assignment context, method invocation, or cast context:
~~~~~~~~~~~~~~~~
Q) about streams?
A) streams :(java.util.stream)(we can find (aggregate operations like) max,min value &count value also &we can convert list to set also byusing Collectors.toset() method)

You can use stream by importing java.util.stream package.

Stream obtained from a collection produces a new Stream without the filtered elements, rather than removing elements from the source collection.

You can use stream to filter, collect, print, and convert from one data structure to other etc.

In the following examples, we have apply various operations with the help of stream.

package com.java8.streams;

import java.util.stream.Collectors;

import java.util.stream.Stream;

import com.java8.model.Person;

public class StreamsTestUsingList {

public static void main(String[] args) {

ArrayList plist = null;

Person p = new Person();

p.setAge(12);

Person p1 = new Person();

p.setAge(1);

Person p2 = new Person();

p2.setAge(2);

Person p3 = new Person();

p3.setAge(3);

plist = new ArrayList();

plist.add(p);

plist.add(p1);

plist.add(p2);

plist.add(p3);

//plist.stream().filter((Person)->p.getAge()<10).forEach((plist)->(p.age));

//stream return collection

//old approach

/* for (Person plistdata : plist) {

if (plistdata.getAge()<10) {

int age = plistdata.getAge();

System.out.println("age ::"+age);

newagelist.add(age);

}

}

/below is for stream approach for above

//usage of strams on the below step1 get age <10 data from list

System.out.println("newagelist ::"+newagelist);*/

//condition //output ?

//Integer person2 = plist.stream().filter((Person)->p.getAge()<10).map((Person)->p.getAge()).findAny().get();

//System.out.println(person2);

//to fetch distinct age from list

//Optional findFirst = plist.stream().distinct().findFirst();

//usage of strams on the below step2 usage of foreach

//plist.stream().filter((Person)->p.getAge()<10).forEach((Person)->System.out.println(p.age));

//usage of strams on the below step3 usage of list set convert

//Set collect = plist.stream().filter((Peson)->p.getAge()<10).map((person)->p.age).collect(Collectors.toSet());

//System.out.println(collect);

//find min and max value form list by using stream().max()

//plist.stream().filter(plist->Person.getAge()==10).max(plist->plist.getAge());

//Person person3 = plist.stream().filter((Person)->p.getAge()<10)

// .max((Person1,Person2)->Person1.age < Person2.age ? 1: -1).get();

//System.out.println(person3.age);

}

}

public class HashMapUsingStreams {

@SuppressWarnings("unchecked")

public static void main(String[] args) {

HashMap hm = new HashMap<>();

hm.put(10, "acda");

hm.put(10, "acd");

hm.put(11, "data1");

hm.put(12, "data2");

//get data greater than 5

Map entrySet =hm.entrySet().stream().

filter(map->map.getKey()>=5).collect(Collectors.toMap(map->map.getKey(),map->map.getValue()));

System.out.println(entrySet);

//output {10=dataa, 11=data1, 12=data2}

//get values by using .equals

Map entrySet2 = hm.entrySet().stream().filter(map->"data".equals(map.getValue()))

.collect(Collectors.toMap(map->map.getKey(),map->map.getValue()));

System.out.println(entrySet2);

//startsWith

Map result = hm.entrySet()

.stream()

//.filter(p -> p.getKey().intValue() <= 2) //filter by key

.filter(map -> map.getValue().startsWith("ac")) //filter by value

.collect(Collectors.toMap(map -> map.getKey(), map -> map.getValue()));

System.out.println(result);

MultiMap map = new MultiValueMap();

map.put("key1", "value1");

map.put("key1", "value2");

System.out.println(map);

Map maps = new HashMap();

maps.put(1,new Employee(1,"",12));

Map maps1 = new HashMap();

maps1.put(1,"a");

ArrayList> al = new ArrayList>();

// al.add((Entry) maps1);

HashMap> Items = new HashMap>();

/*

System.out.println(maps1);

private synchronized void addToList(String mapKey,Employee myItem) {

List itemsList = items.get(mapKey);

// if list does not exist create it

if(itemsList == null) {

itemsList = new ArrayList();

itemsList.add(myItem);

items.put(mapKey, itemsList);

} else {

// add if item is not already in list

if(!itemsList.contains(myItem)) itemsList.add(myItem);

}

}*/

String str="abc";

int strlength = str.length()-1;

System.out.println(str.length()-1);

System.out.println(str.length());

for (int i = 0; i < str.length(); i++) {

System.out.println("str::"+str.charAt(i));

}

for (int i = 0; i < str.length()-1; i++) {

System.out.println("str-1::"+str.charAt(i));

}

}

}

~~~~~~~~~~~~~~~~
Q) Default Methods?
A) defaut is a keyword.. its applicable only for interfaces but must provide body also

we can use static methods also but its having body
~~~~~~~~~~~~~~~~
Q) Optional class 

A)for avoid nullpointer exception we are using

public static void main(String[] args) {

String[] data = new String[10];

// data[0]="A";

Optional ofNullable = Optional.ofNullable(data[0]);

if (ofNullable.isPresent()) {

System.out.println("value in array");

} else {

System.out.println("no value in array");

}
~~~~~~~~~~~~~~~~
Q) Base64 ?
A):for encrypt or decrypt we are using

// Getting encoder

Base64.Encoder decoder = Base64.getMimeDecoder();

// Decoding string

String str = "JavaTpoint";

String dStr = new String(decoder.decode(str));

System.out.println("Decoded string: "+dStr);

}

//output

Decoded string: JavaTpoint

what is asynchronous programming in java 8

ans is :: through CompletableFuture class we can achieve aynchronous .it is comes from util.concurrent package

pls refer https://www.callicoder.com/java-8-completablefuture-tutorial/

~~~~~~~~~~~~~~
Q)quick steps in java 8?

A)
To find the non-repeated words and then get the first word in Java 8, you can use the following approach. This solution involves using Java 8 streams to process the input string, count the occurrences of each word (case-sensitive), and then filter out the repeated words to get the first one.

Here is a step-by-step guide and code example:

Split the input string into words.
Count the occurrences of each word using a Map.
Filter out the words that appear more than once.
Collect the non-repeated words.
Get the first non-repeated word.

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        String input = "heLLo hello rajesh";

        // Split the input string into words
        String[] words = input.split("\\s+");

        // Count the occurrences of each word
        Map<String, Long> wordCounts = Arrays.stream(words)
            .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));

        // Filter out the non-repeated words
        List<String> nonRepeatedWords = wordCounts.entrySet().stream()
            .filter(entry -> entry.getValue() == 1)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());

        // Get the first non-repeated word
        if (!nonRepeatedWords.isEmpty()) {
            System.out.println("First non-repeated word: " + nonRepeatedWords.get(0));
        } else {
            System.out.println("No non-repeated words found.");
        }

        // Print all non-repeated words
        System.out.println("Non-repeated words: " + String.join(" ", nonRepeatedWords));
    }
}

~~~~~~~~~~~~~~~~~~
Q)get second max salary in java8 ?

A)import java.util.*;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("John", 50000),
            new Employee("Jane", 60000),
            new Employee("Doe", 70000),
            new Employee("Mary", 70000),
            new Employee("Paul", 80000)
        );

        Optional<Double> secondMaxSalary = employees.stream()
            .map(Employee::getSalary)            // Extract salaries
            .distinct()                          // Remove duplicates
            .sorted(Comparator.reverseOrder())   // Sort in descending order
            .skip(1)                             // Skip the first (highest) salary
            .findFirst();                        // Get the second highest salary

        if (secondMaxSalary.isPresent()) {
            System.out.println("The second highest salary is: " + secondMaxSalary.get());
        } else {
            System.out.println("There is no second highest salary.");
        }
    }
}


~~~~~~~~
Q)get current date and second friday in java8?

A) in java 8 introduced java.time package

         LocalDate ld = LocalDate.now();//o/p: 2024-04-30
         LocalDate secondFriday = ld.with(TemporalAdjusters.nextOrSame(DayOfWeek.FRIDAY)).with(TemporalAdjusters.next(DayOfWeek.FRIDAY));
~~~~~~~~~~~~~~~~

Q)count of didgits in java8?
A)Arrays.stream(arr).boxed().collect(Collectors.groupingBy(Function.identity(),Collectors.counting()));
{1=1, 2=1, 3=2, 5=1}
~~~~~~~~~~~~~~
Q)without duplicates in java8?
A)s.chars().mapToObj(c->(char)c).distinct().map(Object::toString).collect(Collectors.joining());
collect(Collectors.joining()): Collects the distinct characters into a single String
~~~~~~~~~~~~~~
Q)find duplicates in java8?
A)list.stream().mapToObj(c->(char)c).collect(Collectros.groupingBy(Function.identity())).collect(Collectors.counting())
.entrySet().stream().filter(m->m.getValue>1).map(Map.Entry::getKey).collect(Collectors.toList());

array given duplicate numbers.array given duplicate numbers.
                .map(c -> (char) c.intValue())  // Convert to Character//if array given duplicate numbers.
Set<Character> collect = s.chars().mapToObj(c->(char)c).collect(Collectors.groupingBy(Function.identity(),Collectors.counting()))
		.entrySet().stream().filter(m->m.getValue()>1).map(Map.Entry::getKey).collect(Collectors.toSet());
		System.out.println(collect);

~~~~~~~~~~~~~~
Q)find second max element in java8?
A)Arrays.stream(arr).boxed().distinct().sorted(Comparator.reverseOrder()).skip(1).findFirst().get();
~~~~~~~~~~~~~~
Q)find first non repeated chars in java8?

A) string s ="comparator";

    	List<String> asList = Arrays.asList(s);
    	
    	Map<Character, Long> data=s1.chars().mapToObj(c->(char)c)
    			.collect(Collectors.groupingBy(Function.identity(),Collectors.counting()));
    	
    	List<Character> collect = data.entrySet().stream().filter(e->e.getValue()>1).map(Entry::getKey).collect(Collectors.toList());
    	
    	System.out.println(collect);

~~~~~~~~~~~~~~~~~~~
Category: Collection
Q) what is Collection?

A) Collection is an Interface which can used to Represent a Group of Individual object as a single Entity.

Collections is an utility class to Define several Utility Methods for Collection object.


List ArrayList,LinkedList,Vector,Stack

Set Hashset,LinkedHashset

note:: oka hashset lo string data ni send chesthe idi direct ga string lo vunna .equals call ayi duplicate ni remove chestundi.

so ade customized object ni send chesthe like new Hashset lo hs.add(1,r);new hashset lo hs.add (1,r) idi size 2 ani duplecate data print avuthundi

so denni overcome cheyalante nuvvu tesukunna aa pojo lo ..need to override hashcode and equals.then it gives no duplicates data.

sortedset,Treeset

Map sortedmap,treemap

hashmap,linkedhashmap


time complexity are commonly found in operations on binary trees or when using binary search. An O(log n) algorithm is considered highly .

add remove get contains

ArrayList O(1) O(n) O(1) O(n)

LinkedList o(1)

caopyon arraylist 0(n)
~~~~~~~~~~~~~~~~
Q) what is arrylist?
A)The ArrayList class is a resizable array, which can be found in the java.util package.

The ArrayList class has a regular array inside it. When an element is added, it is placed into the array. If the array is not big enough, a new, larger array is

created to replace the old one and the old one is removed.

Iterable-->Collection-->List-->AbstractList-->ArrayList

Java ArrayList class can contain duplicate elements.

Java ArrayList class maintains insertion order.

Java ArrayList class is non synchronized.

Java ArrayList allows random access because array works at the index basis.

In ArrayList, manipulation is little bit slower than the LinkedList in Java because a lot of shifting needs to occur if any element is removed from the array list.

how the arraylist copy and growable nature shown on below pgm.

default size is 10

once its reaches to load factor the size got dubbeled.so here it will create new object to copy old elements..

from java API ::

/**

* Increases the capacity to ensure that it can hold at least the

* number of elements specified by the minimum capacity argument.

*

* @param minCapacity the desired minimum capacity

*/

private void grow(int minCapacity) {

// overflow-conscious code

int oldCapacity = elementData.length;

int newCapacity = oldCapacity + (oldCapacity >> 1);(or)int newCapacity = (oldCapacity * 3)/2 + 1;

if (newCapacity - minCapacity < 0)

newCapacity = minCapacity;

if (newCapacity - MAX_ARRAY_SIZE > 0)

newCapacity = hugeCapacity(minCapacity);

// minCapacity is usually close to size, so this is a win:

elementData = Arrays.copyOf(elementData, newCapacity);

}

private static int hugeCapacity(int minCapacity) {

if (minCapacity < 0) // overflow

throw new OutOfMemoryError();

return (minCapacity > MAX_ARRAY_SIZE) ?

Integer.MAX_VALUE :

MAX_ARRAY_SIZE;

}

Remove duplicates from arraylist without using collections

package arrayListRemoveduplicateElements;

import java.util.ArrayList;

public class RemoveDuplicates {

public static void main(String[] args){

ArrayList Object al = new ArrayList Object()

al.add("java")

al.add('a');

System.out.println("Before Remove Duplicate elements:"+al);

for(int i=0;i al.size();i++){

for(int j=i+1;j al.size();j++){

if(al.get(i).equals(al.get(j))){

al.remove(j);

j--;

}

}

}

System.out.println("After Removing duplicate elements:"+al);

}

}

~~~~~~~~~~~~~~~~
Q) what is LnkedList?
A) linked list class contains 3 fields 1.link(prev)2.data3.(link (next nodes))..

LinkedList : Iterable--->Collection-->List-->AbstractSequentialList-->LinkedList

The LinkedList class is a collection which can contain many objects of the same type, just like the ArrayList.

The LinkedList class has all of the same methods as the ArrayList class because they both implement the List interface. This means that you can add items, change

items, remove items and clear the list in the same way.

Java LinkedList class uses a doubly linked list to store the elements. It provides a linked-list data structure. It inherits the AbstractList class and implements List

and Deque interfaces.

The important points about Java LinkedList are:

Java LinkedList class can contain duplicate elements.

Java LinkedList class maintains insertion order.

Java LinkedList class is non synchronized.

In Java LinkedList class, manipulation is fast because no shifting needs to occur.

Java LinkedList class can be used as a list, stack or queue.

Doubly Linked List:

In the case of a doubly linked list, we can add or remove elements from both sides.

public class LinkedList1{

public static void main(String args[]){

LinkedList al=new LinkedList();

al.add("Ravi");

al.add("Vijay");

al.add("Ravi");

al.add("Ajay");

Iterator itr=al.iterator();

while(itr.hasNext()){

System.out.println(itr.next());

}

}

}
~~~~~~~~~~~~~~~~
Q) diff of ArrayList and LinkedList or When To Use

A) It is best to use an ArrayList when:

You want to access random items frequently

You only need to add or remove elements at the end of the list

It is best to use a LinkedList when:

You only use the list by looping through it instead of accessing random items

You frequently need to add and remove items from the beginning or middle of the

list

it is fast because no shifting is required.
~~~~~~~~~~~~~~~~
Q) about Hashset ?
A) Hashset : iterable-->collection-->set-->abstractSet-->Hashset

A HashSet is a collection of items where every item is unique, and it is found in the java.util package:

Java HashSet class is used to create a collection that uses a hash table for storage. It inherits the AbstractSet class and implements Set interface.

The important points about Java HashSet class are:

HashSet stores the elements by using a mechanism called hashing.

HashSet contains unique elements only.

HashSet allows null value.

HashSet class is non synchronized.

HashSet doesn't maintain the insertion order. Here, elements are inserted on the basis of their hashcode.

HashSet is the best approach for search operations.

The initial default capacity of HashSet is 16, and the load factor is 0.75

How to add Duplicate elements in Set?

Any Set implementations in Java Collections don't allow to do that.

Consider using MultiSet from Apache Commons Collections.

import org.apache.commons.collections4.MultiSet;

import org.apache.commons.collections4.multiset.HashMultiSet;

public class Test {

public static void main(String[] args) {

MultiSet set = new HashMultiSet<>();

set.add(1);

set.add(1);

set.add(3);

set.add(4);

set.add(5);

set.add(6);

set.forEach(s -> System.out.println(s));

}

}

Result:

1

1

3

4

5

6


how to sort custom hashset object in java

class Test{

public static void main(String args[])

{

// Creating a HashSet

HashSet set = new HashSet();

// Adding elements into HashSet using add()

set.add("geeks");

set.add("practice");

set.add("contribute");

set.add("ide");

System.out.println("Original HashSet: "

+ set);

// Sorting HashSet using List

List list = new ArrayList(set);

Collections.sort(list);

// Print the sorted elements of the HashSet

System.out.println("HashSet elements "

+ "in sorted order "

+ "using List: "

+ list);

}

}

}

Output:

Original HashSet: [practice, geeks, contribute, ide]

HashSet elements in sorted order using List: [contribute, geeks, ide, practice]


hashset lo customized objects duplicate remove cheyalante.

aa pojo loki velli right click chesi we need to override hashcode and equals ivvali.

Example 1::

Person p5 = p4

hs = new Hashset();

hs.add(new Person(1,"adat"));

hs.add(new Person(2,"adct"));

hs.add(new Person(3,"advt"));

hs.add(new Person(1,"adat"));

hs.add(p5);//here set is working properly.

system.out.println(hs.size());//o/p is :: 4

easy way to add hashcode method inyour class:

public int hashcode(){

return this.id+this.age+this.name.hashcode();

}

step 2 :

hashset lo customized objects duplicate remove cheyalante.

HashSet hs = hashset();

hs.add("a");

hs.add("b");

hs.add("a");

o/p: is b because it calls to comparison logic of string class thats y its remove duplicates.

HashSet hs = hashset();

Person p = new Person(1,"d");

Person p1 = new Person(2,"a");

Person p2 = new Person(1,"d");

hs.add(p);

hs.add(p1);

hs.add(p2);

syso(hs.getId())

o/p is :: 1,1,2 because

nuvvu override logic provide lcheyakapothe object class equals ki call avuthundi.

below code provide equlas logic in your class.

public class Person{

public boolean equals(Object obj){

if(obj==this){

return true;

}

if(obj==null){

return false;

}

//sametype of this class or not

if(!(obj instance of Person)){

return false;

}

//manamu create chesina method lo vunna cal avvalante type cast cheyali.

//Person p = (Person)obj

if(!this.name.equals(p.getName())){

return flase;

}

return true;

}

}

~~~~~~~~~~~~~~~~
Q)about HashMap?
A)Hashmap:: Map-->AbstractMap-->HashMap

In the ArrayList chapter, you learned that Arrays store items as an ordered collection, and you have to access them with an index number (int type). A HashMap however, store items in "key/value" pairs, and you can access them by an index of another type (e.g. a String).

One object is used as a key (index) to another object (value). It can store different types: String keys and Integer values, or the same type, like: String keys and String values:

Points to remember

Java HashMap contains values based on the key.

Java HashMap contains only unique keys.

Java HashMap may have one null key and multiple null values.

Java HashMap is non synchronized.

Java HashMap maintains no order.

The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.

what is internal implementation

Each bucket contains a linked list of Map.Entry object,

which contains both Key and Value. Now Java will take the Key object

from each entry and compare with this new key using equals() method,

if that return true then value object in that entry will be replaced by new value

if hash collision is occured(like same hashcode)then it will be called to internally hashcode and equals n method.

duplicate value is removed and latest value is stored by using equals method.

how to get keys and values from hashmap

package com.test;

import java.util.HashMap;

import java.util.Map.Entry;

import java.util.Set;

public class Student {

//finally by using keyset() we get the keys

//from keys we get the values by using get() method.

//or

//by using entryset method ofter for each we get each key and values

//entryset returns Set>

// for(Entry entry:entrySet){

//from entry.getkeys we get key and entry.getValue we get value

public static void main(String[] args) {

HashMap hashmap = new HashMap();

hashmap.put(1, "a");

hashmap.put(2, "b");

/*Setkeys=hashMap.keySet();

System.out.println(keys);

for(Integer allkeys:keys){

System.out.println("keys::"+allkeys);

String value = hashMap.get(allkeys);

System.out.println("values::"+value);*/

Set> entrySet = hashmap.entrySet();

for(Entry entry:entrySet){

System.out.println(entry.getKey());

System.out.println(entry.getValue());

}

}

}

link::http://javaconceptoftheday.com/java-hashmap-programs-and-examples/


how to maintain insertion order in HashMap?

We can use LinkedHashMap for maintain insertion and retrieve order must be same:

If you truly are unable to switch to another Map implementation (LinkedHashMap is exactly what you want), then the only other possibility is to retain the original

List, and use it to create the new List from the Map.

public T ListT listFromMapInOrder(final MapT, T map, final ListT order) {

ListT result = new ArrayListT();

for (T key : order) {

if (map.containsKey(key)) {

result.add(key);

result.add(map.get(key));

}

}

return result;

}

But I would refactor the code until it was possible to switch to a LinkedHashMap.

~~~~~~~~~~~~~~~~
Q)interviewr asked for diff of identity hashmap and hashmap

A)identity hashmap refers == for storing map entry into buckets

hashmap uses .equals for storing map entry into buckets.

~~~~~~~~~~~~~~~~
Q)about Hashtable ?
A)it is synchronized by defult.

multiple thread it is advisable,in single thread it is slow

does not allow null keys or values

it is not failfast,means if concurrent updations are done to hashtable,there will not be

any incorrect results produced by the enumeration.

Hasmap::(key should be unique(means wecannot use duplicate data for keys,it is not synchronized))

we can make hashmap is synchronized using synchronized map

collections.synchronizedmap(new hashmap());

difference of set and list

a set represents a collection of elements order of the elements may change in the set.

not allow duplicate values to be stored.

acess elements by their index based.it is not posiible in case of sets.

not allow null elements.
~~~~~~~~~~~~~~~~

Q)difference of set and list

a set represents a collection of elements order of the elements may change in the set.

not allow duplicate values to be stored.

acess elements by their index based.it is not posiible in case of sets.

not allow null elements.
~~~~~~~~~~~~~~~~

Q)difference of arraylist and vector

A)Vector: Vector is similar to ArrayList but the differences are,

it is synchronized and its default initial size is 10 and when the size exceeds

its size increases to double of the original size that means the new size will be 20.

Vector is the only class other than ArrayList to implement RandomAccess.

it is not synchronized by defult vector is synchrozied by default

we make it synchrozied using synchronizedList

Collections.synchronizedList(new ArrayList());

2.incase of single thread,using arrylist multithread is advisable,

is faster than vector in single thread ,its slow

3.Arraylist increases its size everytime by 50 percent(half) its size everytime by doubling it.

~~~~~~~~~~~~~~~~
Q)Difference of Hashmap and Hashtable:
A)1)Hashtable is synchronized whereas hashmap is not.

2)Another difference is that iterator in the HashMap is fail-safe while the enumerator for the Hashtable isn't. If you change

the map while iterating, you'll know.

3)HashMap permits null values in it, while Hashtable doesn't.
~~~~~~~~~~~~~~~~
Q)about Collection framework(9 key interfaces)
A)Interfaces: An Interface provides much information than classes. Class is the implementation of an interface.

1) Collection:

When we should go for collection: To represent a group of elements as one entity.

collection interface is the root interface of all interfaces.

2) List Interface: (1.2 v)

Duplicates are allowed and insertion order is preserved then we must go for this interface.

List is the child interface of Collection.

Implementation classes: ArryaList(1.2 v), LinkedList(1.2 v), Vector (1.0 v), Stack(1.0 v).

Legacy classes are Vector and Stack.

3) Set Interface(1.2 v):

Duplicates are not allowed.

Insertion order is not preserved.

Child interface of collection.

Implementation classes: HashSet (1.2 v) and LinkedHashSet(1.4 v).

4) SortedSet Interface (1.2 v):

Child interface of Set.

Duplicates are not allowed.

Insertion order is preserved.

5) Navigable Set Interface:(1.6 v)

Child interface of SortedSet.

Implementation class: TreeSet (1.6 v).

6) Queue Interface:(1.5 v)

Child Interface of Collection.

A group of objects prior to process this can be used.

Implementation class: PriorityQueue, BlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue.

All the above interfaces are ment for represent a group of individual objects.

When need to represent key value pairs then below interfaces.

7) Map Interface: (key, value) (1.2 v)

Not a child interface of collection.

A group of objects as key value pairs.

Duplicate keys are not allowed but values can be allowed.

Implementation classes: HashMap(1.2 v), LinkedHashMap(1.4 v), WeekHashMap(1.2), IdentityHashMap(1.4), Hashtable, Properties.

Dictionary(1.0 v) is the parent class for Hashtable followed by Properties. These are called legacy classes.

8) SortedMap Interface: (1.2 v)

A group of objects key value pairs according to some sorting method.

Child interface of Map.

9) NavigableMap Interface:(1.6 v)

Child interface of SortedMap.

Defines several utility methods for navigation.

Implementation class: TreeMap. (1.2 v)
~~~~~~~~~~~~~~~~
Q)Failfast and Fail safe:

A)When one or more thread is iterating over the collection,

in between, one thread changes the structure of the collection

(either adding the element to the collection or by deleting the element in the collection or

by updating the value at particular position in the collection) is known as Concurrent Modification

or failfast.

created on a clone of that collection. One example which supports failsafe iterator is ConcurrentHashMap.

modification in the collection Fail-fast iterators throw ConcurrentModificationException

Example for fail fast iterators are ArrayList, Vector, HashSet

~~~~~~~~~~~~~~~~
Q)Difference of vector and arraylist::

A)Vector: Vector is similar to ArrayList but the differences are,

it is synchronized and its default initial size is 10 and when the size exceeds

its size increases to double of the original size that means the new size will be 20.

Vector is the only class other than ArrayList to implement RandomAccess.

~~~~~~~~~~~~~~~~
Q)Difference of Hashmap and Hashtable:

A)1)Hashtable is synchronized whereas hashmap is not.

2)Another difference is that iterator in the HashMap is fail-safe while the enumerator for the Hashtable isn't. If you change

the map while iterating, you'll know.

3)HashMap permits null values in it, while Hashtable doesn't.
~~~~~~~~~~~~~~~~~
Category: Exceptions
Q) Exceptions:

A) checked Exceptions::(complietime)::IO,SQL,classnotfound exception

unchecked Exceptions(Runtime)::arithmetic,nullpointer,numberformat,indexoutofbound exception(string,array)

Checked exception(like nullpointer) cannot be propagated using throw.but throws it will handle checked exception

The keyword throw is used inside method body to invoke an exception and

throws clause is used in method declaration (signature).

Example ::userdefined exception

first table gani query lo gani edaina modifications chesi.avi ee type of exceptions vastunayo chudali(like querysyntax,sql grammer exceptions)

aa vachina exceptions catch lo pettukoni like catch(QuerysyntaxException q){throw new ApplicationExeption("ikada manamu create chesina userdefined object ni

throw cheyali.")}

public class CAExceptions extends NestedRuntimeException{

private static final long serialVersionUid=1L;

public CAExceptions(String msg) {

super(msg);

// TODO Auto-generated constructor stub

}

public CAExceptions(String msg, Throwable cause) {

super(msg);

// TODO Auto-generated constructor stub

}

//manamu create chesina exception msg constructor nundi tesukoni aa msg ni super(exception)class ki send chestundi.

so again nuvvu aa msg ni tesukovalante catch(ApplicationExcepton ae){"message",ae.getmessage()}ila aunte malli manaku manamu set

chesina msg display chestundi.

throw ae annapudu..aa method throws lo (ApplicationExcepton vundali. okna)

public class Myexception extends Exception {

private String message;

Myexception(String message)

{

this.message=message;

}

public String toString(){

return ("Output String = "+message) ;

}

}

public class MyownException {

public static void main(String[] args) {

try{

throw new Myexception("Custom");

}

catch(Myexception me){

System.out.println(me);

me.printStackTrace();

}

}

Output:

Hi this is my catch block

Output String = Custom

checked exceptions are checked at compile time.

it means if a method is throwing a checked exception

we need to handle byusing try catch or throws keyword

for example:fis = new FileInputStream("B:/myfile.txt");

unchecked exceptions::

Unchecked exceptions are not checked at compile time.

Most of the times these exception occurs due to the bad

data provided by user during the user-program interaction.

int arr[] ={1,2,3,4,5};

ArrayIndexOutOfBoundsException*/

System.out.println(arr[7]);



ExceptionHandling with MethodOverriding in Java ::

ref:: https://www.javatpoint.com/exception-handling-with-method-overriding


 If the superclass method declares no exception
 conclusion: parent class method lo exception ledu.child checked ivakudadu ..unchecked isthe no issue.


1) Rule: If the superclass method does not declare an exception, subclass overridden method cannot declare the checked exception.

2) Rule: If the superclass method does not declare an exception, subclass overridden method cannot declare the checked exception but can declare unchecked exception.

3) Rule : If the superclass method declares an exception, subclass overridden method can declare same, subclass exception or no exception but cannot declare parent exception.

next →← prev

-->super has checked exception declare same checked exception in sub class also

-->super has checked no exception declare unchecked exception.

super lo exception vunte child lo exception vundavachu.

super lo Exception vunte child lo unchecked is possible.

super lo Exception vunte child lo no exception is possible.

1.super lo exception ledu kani sub lo no checked .

unchecked vundavachu.

2.super lo exception unchecked vundi.sub lo unchecked vundali.

parentclass(Exception) vundakudadu.

Example ::Example in case subclass overridden method declares same exception

class Parent{

void msg()throws Exception{System.out.println("parent");}

}

class TestExceptionChild3 extends Parent{

void msg()throws Exception{System.out.println("child");}

Output:child

Example 2 : by using controler advice

from CTS videos::

@ControllerAdvice

@RestController

public class CustomResponseExceptionHandler extends ResponseEntityExceptionHandler {

@ExceptionHandler(OldLaptapIdException.class)

public final ResponseEntity Object> handleProjectIdException(OldLaptapIdException ol, WebRequest req) {

OldLaptapIdException oldLaptapIdExceptionResponse = new OldLaptapIdException(ol.getMessage());

return new ResponseEntity(oldLaptapIdExceptionResponse, HttpStatus.BAD_REQUEST);

}

(++++++++or+++++++)

@ExceptionHandler(ResourceNotFoundException.class)

@ResponseStatus(value = HttpStatus.NOT_FOUND)

public @ResponseBody ExceptionResponse handleResourceNotFound(final ResourceNotFoundException exception,

final HttpServletRequest request) {

ExceptionResponse error = new ExceptionResponse();

error.setErrorMessage(exception.getMessage());

error.callerURL(request.getRequestURI());

return error;

}

}

@Service

public class OldLapService {

@Autowired

private OldLapRepository olp;

public OldLaptapDetails saveOldLap(OldLaptapDetails old) {

try {

OldLaptapDetails saveLap = olp.save(old);

return saveLap;

} catch (Exception e) {

throw new OldLaptapIdException("OldLaptap ID'" + old.getOldLaptapId() + "'already exist");

}

}

}

Exceptions Handling by using catch blocks

catch(Exception e){//here unrechable catch error showing.

e.printstacktrace();

}

catch(NUllpointerException ne){

ne.printstacktrace();

}

Note:: Exception class is must mention at last only.



Exception class Methods(6)::

public String getMessage()

public Throwable getCause()

public String toString()

public void printStackTrace()

public StackTraceElement[]getStackTrace()

public Throwable fillInStackTracae()

~~~~~~~~~~~~~~
Category: Stringclass
Q) about Stringclass

A) String class::methods::chatAt,intern(obj to pool),length(),replace

string is immutable

stringBuffer(synchronized),mutable

reverse();append();

SCP-->string s="abc"-->saved into pool

String s="xyz"-->saved into pool and content is xyz,but xyz is garabe collected.

 s="abc"-->saved to pool//abc is in memroy

String s1="abc"-->saved to pool memory but abc content having two references.duplicates not allowed

s=s1-->o/p:is true because content cheking

s==s1-->o/p:false because reference checking

interviewr asked diff of final and immutable?

so ans is : final reference not changed but imutable reference has changed.

What is the purpose of method parseInt defined in Integer class.

The method is used to convert String to an integer,

assuming that the String represents an integer.

We can convert String to int in java using Integer.parseInt() method.

int i=Integer.parseInt("200");

output::

200


how to create immutable class

below rules are followed for create immutable class

1.final class

2.private final variable

3.constructor in deep copy

4.only getter methods.


interviewr asked ?how to sort the below array.

string data[] ={asd,sdfs,werewr};

so ans is : with arr[i].compareto(arr[j])>0 )then swap the elements. so compareto follows by natural(by alphabets)sorting also.

package com.Stringtest;

import java.util.Arrays;

public class SortArray {

    public static void main(String[] args) {
        String data[] ={"tsd","adfs","qerewr"};
        for(int i=0;i< data.length-1;i++){
           for (int j=i+1;j< data.length-1;j++){
              if(data[i].compareTo(data[j])>0){
                    String temp =data[i];
                    data[i]=data[j];
                    data[j]=temp;
              }

           }
        }
     System.out.println(Arrays.toString(data));
    }
}
output: [adfs, tsd, qerewr]

public final class String

extends Object

implements Serializable, Comparable, CharSequence

The String class represents character strings. All string literals in Java programs, such as "abc", are implemented as instances of this class.

Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be

shared. For example:

String str = "abc";

is equivalent to:

char data[] = {'a', 'b', 'c'};

String str = new String(data);

Here are some more examples of how strings can be used:

System.out.println("abc");

String cde = "cde";

System.out.println("abc" + cde);

String c = "abc".substring(2,3);

String d = cde.substring(1, 2);

The class String includes methods for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings, and for

creating a copy of a string with all characters translated to uppercase or to lowercase. Case mapping is based on the Unicode Standard version specified by the

Character class.



@FunctionalInterface

public interface Comparator

A comparison function, which imposes a total ordering on some collection of objects. Comparators can be passed to a sort method (such as Collections.sort or

Arrays.sort) to allow precise control over the sort order. Comparators can also be used to control the order of certain data structures (such as sorted sets or sorted

maps), or to provide an ordering for collections of objects that don't have a natural ordering.

The ordering imposed by a comparator c on a set of elements S is said to be consistent with equals if and only if c.compare(e1, e2)==0 has the same boolean value as

e1.equals(e2) for every e1 and e2 in S.

Caution should be exercised when using a comparator capable of imposing an ordering inconsistent with equals to order a sorted set (or sorted map). Suppose a sorted

set (or sorted map) with an explicit comparator c is used with elements (or keys) drawn from a set S. If the ordering imposed by c on S is inconsistent with equals,

the sorted set (or sorted map) will behave "strangely." In particular the sorted set (or sorted map) will violate the general contract for set (or map), which is

defined in terms of equals.

For example, suppose one adds two elements a and b such that (a.equals(b) && c.compare(a, b) != 0) to an empty TreeSet with comparator c. The second add operation will

return true (and the size of the tree set will increase) because a and b are not equivalent from the tree set's perspective, even though this is contrary to the

specification of the Set.add method.



next »« prev

Java String compareTo()

The java string compareTo() method compares the given string with current string lexicographically. It returns positive number, negative number or 0.

It compares strings on the basis of Unicode value of each character in the strings.

If first string is lexicographically greater than second string, it returns positive number (difference of character value). If first string is less than second string

lexicographically, it returns negative number and if first string is lexicographically equal to second string, it returns 0.

Internal implementation

public boolean equals(Object anObject) {

if (this == anObject) {

return true;

}

if (anObject instanceof String) {

String anotherString = (String) anObject;

int n = value.length;

if (n == anotherString.value.length) {

char v1[] = value;

char v2[] = anotherString.value;

int i = 0;

while (n-- != 0) {

if (v1[i] != v2[i])

return false;

i++;

}

return true;

}

}

return false;

}



Java String equals()

The java string equals() method compares the two given strings based on the content of the string. If any character is not matched, it returns false. If all characters

are matched, it returns true.

The String equals() method overrides the equals() method of Object class.

Internal implementation

public boolean equals(Object anObject) {

if (this == anObject) {

return true;

}

if (anObject instanceof String) {

String anotherString = (String) anObject;

int n = value.length;

if (n == anotherString.value.length) {

char v1[] = value;

char v2[] = anotherString.value;

int i = 0;

while (n-- != 0) {

if (v1[i] != v2[i])

return false;

i++;

}

return true;

}

}

return false;

}

Signature

public boolean equals(Object anotherObject)

~~~~~~~~~~~~~~~~~~~~~~~~

